#summary A Look at Kalimat Lexical Analyzer in depth.

= Introduction =

== Table of Classes ==

    # *Class BufferState.*
    # *Class Buffer.*

= Details =

===Class BufferState === 

    {{{
    QString buffer;//Input buffer stream.
    int p1,p2; //buffer position indices's.
    int col, line; //Tracks current column and Line.
    bool startOfLine;
    }}}
===Class Buffer=== 

    {{{
    //Data Members(same as Class BufferState)
    QString buffer;
    int p1,p2;
    int col, line;
    bool startOfLine;
    
    //Functions
    void init(QString buffer) initialize the Buffer with given String.
    bool eof()         //check if we are already at the end of the buffer stream
    bool eof(int pos)  //check if given pos 

    //all readAhead functions don't advance p2 Unlike read() function return 
    //the boolean value of checking if the current char at offset from current
    //p2 is equal to “c” or not or if the string ahead is equal to “s” all  
    //checks are considered with an offset from p2.
    {
      bool readAhead(QChar c);
      bool readAhead(QChar c, int offset);
      bool readAhead(QString s);
    }

    QChar read(); //read current char and increment p2 pointer.
    
    //returns the QString between p1 and p2, inclusive. and sets p1 = p2.
    QString accept(int &line, int &col, int &pos);

    //returns the QString that would've been returned by accept(),but doesn't 
    //moveahead the pointer 'p1' to equal 'p2'
    QString acceptable();
    }}}

===Struct StateMachine ===
{{{
struct StateMachine

    TransitionTable _transitions; // a transition table is a QMap<State, QVector<ConditionAndAction> >
                                 // i.e given a State it gives us a list of "condition/action" pairs that we can use to specify
                                // state transitions.
    // given a current state and input, gives us the next state
    bool Transition(State s, Buffer &_buffer, State & nextState,bool &accept, TokenType & acceptedType, Action*& action);
    // Add: takes a current state 's', a predicate 'c', a next state 's2', flags if the state needs them, and a tokenType for the accepted token if the state is accepting.
    void add         (State s, Predicate *c, State s2);
    void add         (State s, Predicate *c, State s2, Action *action);
    void addAccepting(State s, Predicate *c, State s2, TokenType accepted);
    void addAccepting(State s, Predicate *c, State s2, TokenType accepted, Action *action);
    // another version of add with simplified default parameters
    QVector<Predicate *> GetPossibleTransitions(State s);
    // are there any transitions from this state?
    bool StateHasTests(State s);
    // checks if the state has the 'retract' flag
    bool  IsStateGoBack(State s);
    bool StateHasFlag(State s,int flag); };
}}}