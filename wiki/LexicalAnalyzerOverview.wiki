#summary A Look at Kalimat Lexical Analyzer in depth.

= Introduction =

== Table of Classes ==

    # *Class BufferState.*
    # *Class Buffer.*
    # *Struct StateMachine.*
    # *Class Token.*
    # *Class UnexpectedCharException.*
    # *Class TransitionTestPair.*
    # *Class Lexer.*

= Details =

===Class BufferState === 

    {{{
    QString buffer;//Input buffer stream.
    int p1,p2; //buffer position indices's.
    int col, line; //Tracks current column and Line.
    bool startOfLine;
    }}}
===Class Buffer=== 

    {{{
    //Data Members(same as Class BufferState)
    QString buffer;
    int p1,p2;
    int col, line;
    bool startOfLine;
    
    //Functions
    void init(QString buffer) initialize the Buffer with given String.
    bool eof()         //check if we are already at the end of the buffer stream
    bool eof(int pos)  //check if given pos 

    //all readAhead functions don't advance p2 Unlike read() function return 
    //the boolean value of checking if the current char at offset from current
    //p2 is equal to “c” or not or if the string ahead is equal to “s” all  
    //checks are considered with an offset from p2.
    {
      bool readAhead(QChar c);
      bool readAhead(QChar c, int offset);
      bool readAhead(QString s);
    }

    QChar read(); //read current char and increment p2 pointer.
    
    //returns the QString between p1 and p2, inclusive. and sets p1 = p2.
    QString accept(int &line, int &col, int &pos);

    //returns the QString that would've been returned by accept(),but doesn't 
    //moveahead the pointer 'p1' to equal 'p2'
    QString acceptable();
    }}}

===Struct StateMachine ===

    {{{
    //QMap<State, QVector<ConditionAndAction>>
    TransitionTable _transitions; 
   
    // given a current state and input, gives us next state
    bool Transition(State s, Buffer &_buffer, State & nextState,bool &accept,
                   TokenType & acceptedType, Action*& action);

    //Add: takes a current state 's', a predicate 'c', a next state 's2',
    //flags if the state needs them, and a tokenType for the accepted token 
    void add         (State s, Predicate *c, State s2);
    void add         (State s, Predicate *c, State s2, Action *action);
    void addAccepting(State s, Predicate *c, State s2, TokenType accepted);
    void addAccepting(State s, Predicate *c, State s2, TokenType accepted,
                      Action *action);

    //Given a State returns all possible predicate Transition from it
    QVector<Predicate *> GetPossibleTransitions(State s);

    //Check if there are any transitions
    bool StateHasTests(State s);
    }}}

===Class Token===

*We have four types of Tokens*
 # *TokenNone* (given int value -1) Tokens of type 'TokenNone' are skipped during lexical analysis.
 # *TokenInvalid* (given int value -2) Invalid tokens are returned by functions that return tokens when they shouldn't, for example Parser.getPos() at the end of file.
 # *TokenWithNext* (-3) & *TokenWithPrev* (-4) that have similar behavior Tokens of type 'WithNext' are skipped when returning the tokenized program, but attached to the 'sister' field in the following token in the token stream the token is lost if there is no following token.

    {{{
    QString Lexeme;
    TokenType Type;
    int Line, Column, Pos;
    void *tag;
    Token *sister;

    //Constructors.
    Token(QString lexeme, TokenType type);
    Token(Token const &other);
    Token();

    //Boolean Operators “==” and “!=” to compare Two Tokens.
    bool operator ==(Token &t2);
    bool operator !=(Token &t2);
    Token &operator = (const Token &other);

    //Overloaded Function “Is” has two signatures either taking lexeme 
    //and compare it or TokenType and checks if they are the same.
    bool Is(QString lexeme);
    bool Is(TokenType type);
    }}}

===Class UnexpectedCharException===
    {{{
    QVector<Predicate *> _transitions;
    QString gotThis; //un-expected char that caused the error while parsing
    int line, column, pos;
    int state;
    QString fileName;

    UnexpectedCharException(QString _gotThis, QVector<Predicate *> 
                            possibleTransitions, int line, int column,
                            int pos, int state, QString fileName);
    
    //Err Message = ("Unexpected char:'UnExpectedChar',FileName (Line,Column,
    //               Position) state='State', char code = Char Unicode")       
    QString buildMessage();
    }}}

===Class TransitionTestPair===

Every State holds a vector of TransitionTestPair class where when the Lexical analyzer is at state S will iterate it's vector and try each predicate of the item to check if it holds a valid transition to state S' found in the TransitionTestPair object. 
    {{{
    public:
    Predicate *c;
    State s;
    Action *action;
    bool accepting;
    TokenType acceptedType;

    public:
    TransitionTestPair();
    TransitionTestPair(Predicate *c1, State s1);
    TransitionTestPair(Predicate *c1, State s1, TokenType _acceptedType);
    TransitionTestPair(Predicate *c1, State s1, Action *_action);
    TransitionTestPair(Predicate *c1, State s1, TokenType _acceptedType,
                       Action *_action); 
    }}}

===Class Lexer===
    
    {{{
    int state;
    QVector<Token> acceptedTokens;
    void *tokenTag;
    QString fileName; // For debugging messages only

    public:
    
    Lexer();
    Lexer(StateMachine sm);
    void init(QString s);
    void init(QString s, void *tag);
    void init(QString s, void *tag, QString fileName);
    // Runs the state machine and keeps adding accepted tokens to a vector
    void tokenize(bool ignoreUnexpectedChar=false); 
    QVector<Token> getTokens(); // Returns all accepted tokens

    protected:
     
    StateMachine stateMachine;
    Buffer buffer;
    virtual Token accept(TokenType);
    }}}

===Class Predicate===

class Predicate;

Predicate *loop(Predicate *p);
Predicate *choice(Predicate *p1, Predicate *p2);
Predicate *seq(Predicate *p1, Predicate *p2);
Predicate *seq(Predicate *p1, Predicate *p2, Predicate *p3);
Predicate *seq(Predicate *p1, Predicate *p2, Predicate *p3, Predicate *p4);
Predicate *seq(Predicate *p1, Predicate *p2, Predicate *p3, Predicate *p4, Predicate *p5);
Predicate *la(CharPredicate *p);
Predicate *la(QChar p);

class Predicate

    virtual bool operator()(Buffer &b)=0;

class LA : public Predicate
{
    CharPredicate *predicate;
public:
    LA(CharPredicate *pred);
    virtual bool operator()(Buffer &b);
};

class LAStr : public Predicate
{
    QString str;
public:
    LAStr(QString s);
    LAStr(QStdWString s);
    virtual bool operator()(Buffer &b);
};

class Else: public Predicate
{
public:
        Else();
        bool operator()(Buffer &b);
};
class LineStart : public Predicate
{
public:
    bool operator()(Buffer &b);
};
class Eof: public Predicate
{
public:
        Eof();
        bool operator()(Buffer &b);
};
class ReSeq : public Predicate
{
    int predicateCount;
    Predicate ** predicates;
public:
    ReSeq(Predicate *p1, Predicate *p2);
    bool operator()(Buffer &b);
};
class ReChoice : public Predicate
{
    int predicateCount;
    Predicate ** predicates;
public:
    ReChoice(Predicate *p1, Predicate *p2);
    bool operator()(Buffer &b);
};

class ReLoop : public Predicate
{
    Predicate * predicate;
public:
    ReLoop(Predicate *p);
    bool operator()(Buffer &b);
};


===Class CharPredicate===

class CharPredicate

        virtual bool operator()(QChar c)=0;

class CharEquals : public CharPredicate
{
        QChar _c;
public:
        CharEquals(QChar c);
        bool operator()(QChar c);
};
class CharNotEqual : public CharPredicate
{
        QChar _c;
public:
        CharNotEqual(QChar c);
        bool operator()(QChar c);
};
class CharIsLetter : public CharPredicate
{
public:
    bool operator()(QChar c);
};
class CharRange: public CharPredicate
{
        QChar _c1, _c2;
public:
        CharRange(QChar c1, QChar c2);
        bool operator()(QChar c);
};
class CharOr: public CharPredicate
{
        CharPredicate *_a;
        CharPredicate *_b;
public:
        CharOr(CharPredicate *a, CharPredicate *b);
        bool operator()(QChar c);
};
class AnyChar : public CharPredicate
{
public:
    AnyChar();
    bool operator()(QChar c);
};


