#summary A Look at Kalimat Lexical Analyzer in depth.

= Introduction =

Kalimat Lexer Physically implements the FSM(Finite State Machine) Lexical Analyzer for Tokenizing(process of recognizing the language set of characters that form a token) the input buffer according to a *TransitionTable* formed by deciding the transiton from a State A to a State B according to a *Predicate* simulating the idea of edge transition in the FSM where the current input char is the condition of transition.

The *StateMachine* starts at Start state and begin reading the input character to decide the next state of transition let's simulate the possible events between accepting, non-accepting and error states.

    # *A -> B (non-final to non-final):* the state machine keeps moving and accumulating the input char.
    # *A -> null (non-final to null) :* we are at State A and we don't have any transitions on given input char the StateMachine will signals an error that we have an *UnExpectedChar Exception*.
    # *C -> null (final to null):* that means we have found an accepting token since we are already at an accepting state and the input char isn't needed anymore.

----
== Table of Classes ==

    # *Class BufferState.*
    # *Class Buffer.*
    # *Struct StateMachine.*
    # *Class Token.*
    # *Class UnexpectedCharException.*
    # *Class TransitionTestPair.*
    # *Class Lexer.*
    # *Class KalimatLexer.*
    # *Class Predicate.*
    # *Class CharPredicate.*

----
= Details =

===Class BufferState === 

The class represents the current buffer status with a set of member variables same found in the Buffer Class, where it acts as a temporary variable to save the buffer status inorder to retract to an old version later if needed.

    {{{
    QString buffer;//Input buffer stream.
    int p1,p2; //buffer position indices's.
    int col, line; //Tracks current column and Line.
    bool startOfLine;
    }}}

===Class Buffer=== 

    {{{
    //Data Members(same as Class BufferState)
    QString buffer;
    int p1,p2;
    int col, line;
    bool startOfLine;
    }}}

Two signatures of the Function Eof to check if we are already at the end of the buffer stream or if the passed position is.

    {{{
    bool eof()         
    bool eof(int pos)
    }}}
  
Take care that all *readAhead* functions don't advance p2 Unlike read() function return the boolean value of checking if the current char at offset from current p2 is equal to “c” or not or if the string ahead is equal to “s” all checks are considered with an offset from p2.

    {{{
    bool readAhead(QChar c);
    bool readAhead(QChar c, int offset);
    bool readAhead(QString s);
    }}}

Responsible to read current char and increment p2 pointer also checks if we are at a newline.

    {{{
    QChar read();
    }}}
    
Returns the string between p1 and p2, inclusive. and then at last sets p1 = p2.

    {{{
    QString accept(int &line, int &col, int &pos);
    }}}

Another version of accept() returns the QString that would've been returned by but doesn't moveahead the pointer p1 to equal p2.

    {{{
    QString acceptable();
    }}}

===Struct StateMachine ===

*StateMachine* is the physical implementation of regular expressions state machines, where you define a state and the possible transitions from this state to another states(TransitionTable). If for a certain input char at a certain state you defined two unequal transitions for same input the State Machine will always choose the first defined one so it Models the Finite State Machines.

*TransitionTable* is a Map with States as a Key and a Vector of transition states according to predicates(explained latter) conditions.
    
    {{{
    // given a current state and input, gives us next state
    bool Transition(State s, Buffer &_buffer, State & nextState,bool &accept,
                   TokenType & acceptedType, Action*& action);
    }}}

Different signatures of the add function to set a Transition state for a certain state "S" with the Predicate condition.
    {{{
    //Add: takes a current state 's', a predicate 'c', a next state 's2',
    //flags if the state needs them, and a tokenType for the accepted token 
    void add         (State s, Predicate *c, State s2);
    void add         (State s, Predicate *c, State s2, Action *action);
    void addAccepting(State s, Predicate *c, State s2, TokenType accepted);
    void addAccepting(State s, Predicate *c, State s2, TokenType accepted,
                      Action *action);
    }}}

===Class Token===

*We have four types of Tokens: *
 # *TokenNone* (given int value -1) Tokens of type 'TokenNone' are skipped during lexical analysis.
 # *TokenInvalid* (given int value -2) Invalid tokens are returned by functions that return tokens when they shouldn't, for example Parser.getPos() at the end of file.
 # *TokenWithNext* (-3) & *TokenWithPrev* (-4) that have similar behavior Tokens of type 'WithNext' are skipped when returning the tokenized program, but attached to the 'sister' field in the following token in the token stream the token is lost if there is no following token.

*Data Members:* are the lexeme of the accepted token, it's type(which are the 4-types mentioned above), line, column, the Token_Tag and it's sister.
    {{{
    QString Lexeme;
    TokenType Type;
    int Line, Column, Pos;
    void *tag;
    Token *sister;
    }}}
   
===Class UnexpectedCharException===

When the state machine is at a non-accepting state and an unexpected char is read Signal an error message with the line, position, character responsible.

    {{{   
    //Err Message = ("Unexpected char:'UnExpectedChar',FileName (Line,Column,
    //               Position) state='State', char code = Char Unicode")       
    QString buildMessage();
    }}}

===Class TransitionTestPair===

Every State holds a vector of TransitionTestPair class where when the Lexical analyzer is at state A will iterate it's vector and try each predicate of the item to check if it holds a valid transition to state B. 

    {{{
    //Data Members
    Predicate *c;
    State s;
    Action *action;
    bool accepting;
    TokenType acceptedType;
    }}}

*TransitionTestPair Constructor* have more than one version.
   # *First Constructor* sets the Action to NULL, accepting value false and acceptedType default to Zero.
   # *Second Constructor* sets the Action value passed, accepting value false and acceptedType default to Zero.
   # *Third Constructor* sets the Action to NULL, accepting to true since we have a passed acceptedType.
   # *Last Constructor* sets all value passed and sets accepting to true.

    {{{
    TransitionTestPair(Predicate *c1, State s1)
    TransitionTestPair(Predicate *c1, State s1, Action *_action)
    TransitionTestPair(Predicate *c1, State s1, TokenType _acceptedType)
    TransitionTestPair(Predicate *c1, State s1, TokenType _acceptedType, 
                       Action *_action)
    }}}

===Class Lexer===

The class holds very important function *tokenize* which is responsible for generating the token stream from the input code.

First the function enters an infinite loop which is terminated iff(if and only if) we are at the end of the buffer or we have an UnExpectedChar and we don't ignore UnExpectedChar which will throw an Exception message.

We call the state machine sending current state and buffer and returning a success Transition with a next state and action to be done on the buffer stream like we have read an extra character which need to be retracted.

    {{{
    while(true)
    {
        if(buffer.eof())
            readEof = true; // schedule terminating after next loop iteration

        if(stateMachine.Transition(state, buffer, nextState, accepted, acceptedType, action))
        {
            state= nextState;
            if(action != NULL)
                (*action)(buffer);
         }
    }
    }}}

The case when we don't ignore *UnExpected Character* in the stream it throws an Exception object of *Class UnexpectedCharException*.

    {{{ 
    if(!ignoreUnexpectedChar)
            
       QString curChar;
       if(buffer.eof())
           curChar = "<EOF>";
       else
       {
           curChar = QString("%1").arg(buffer.read());
           throw UnexpectedCharException(curChar, stateMachine.GetPossibleTransitions(state), buffer.GetLine(), buffer.GetColumn(), buffer.GetPos(), state, fileName);
       }
     }}}
     

     {{{            
     int l,c,p;
     buffer.accept(l,c,p);
     state = 0;   

        if(accepted)
        
            Token t = accept(acceptedType);
            if(t.Type != TokenNone)
                acceptedTokens.append(t);
        

        if(readEof)

            // We cannot exit the loop whenever readEof is true, because
            // an action might have retracted the buffer to before the EOF position
            // therefore we also test if we are still at the EOF position before breaking
            // the loop
            if(buffer.eof())
                break;
            else
                readEof = false;

    }}}

===Class KalimatLexer===

 # it's a sub-class of *Lexer* which holds all the *Predicates* and *CharPredicates* that are needed to recognize language tokens in our *StateMachine*. 
 # it's also responsible for initializing the language keywords and arabic chars by reading text files and saving them to a QMap to retrieve the id of the keyword latter or save name of certain special arabic chars.

    {{{
    // reads the text file "keywords.txt"
    void InitKeywords()

    // reads the text file "arab_char.txt"
    void InitArabChars()
    }}}

===Class Predicate===

The class holds a *virtual operator()* that's given the buffer as an input it tries to test certain conditions of accepting and then returning a true or false defining the acceptance or failure of matching.

    {{{
    //virtual Operator that's overloaded in subclasses
    virtual bool operator()(Buffer &b)=0;
    }}}

The set of sub-classes from *class Predicate* overrides the definition of the *operator() * to recognize certain conditions:
   # *Class LA :* LookAhead if the passed char pass the Predicate Test.
   # *Class LAStr :* LookAhead a given string and return true if passed buffer holds the given string.
   # *Class Else :* Always returns true.
   # *Class LineStart :* Check if the passed buffer is at the start line.
   # *Class Eof :* Check if the passed buffer is at the EOF state.
   # *Class ReSeq :* Takes Set of Predicates and returns true if all of them pass. 
   # *Class ReChoice :* Takes a set of Predicates and check if any of them pass.
   # *Class ReLoop :* read on the buffer while predicate check pass. 

===Class CharPredicate===

The class holds a *virtual operator()* that's given a char argument it checks a certain condition with it's data member variable and then returns a true or false defining condition matching:
    {{{
    //virtual Operator that's overloaded in subclasses
    virtual bool operator()(QChar c)=0;
    }}}

the set of sub-classes derivd from *class CharPredicate* wich overload the *operator()* to check certain conditions on the argument char and the member one:
   # *Class CharEquals :* check if passed char equals it's char variable. 
   # *Class CharNotEqual .* check if passed char not-equals it's char variable.
   # *Class CharIsLetter :* check if passed char isLetter.
   # *Class CharRange :* check if passed char is in a given range.
   # *Class CharOr :*  check if passed char equals one of two chars.
   # *Class AnyChar :* accepts any char.
 