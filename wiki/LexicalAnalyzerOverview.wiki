#summary A Look at Kalimat Lexical Analyzer in depth.

= Introduction =

== Table of Classes ==

    # *Class BufferState.*
    # *Class Buffer.*
    # *Struct StateMachine.*
    # *Class Token.*
    # *Class UnexpectedCharException.*
    # *Class TransitionTestPair.*
    # *Class Lexer.*
    # *Class KalimatLexer.*
    # *Class Predicate.*
    # *Class CharPredicate.*

= Details =

===Class BufferState === 

The class represents the current buffer status with a set of member variables same found in the Buffer Class, where it acts as a temporary variable to save the buffer status inorder to retract to an old version later if needed.

    {{{
    QString buffer;//Input buffer stream.
    int p1,p2; //buffer position indices's.
    int col, line; //Tracks current column and Line.
    bool startOfLine;
    }}}

===Class Buffer=== 

    {{{
    //Data Members(same as Class BufferState)
    QString buffer;
    int p1,p2;
    int col, line;
    bool startOfLine;
    }}}

Two signatures of the Function Eof to //check if we are already at the end of the buffer stream or if the passed position is.

    {{{
    bool eof()         
    bool eof(int pos)
    }}}
  
All readAhead functions don't advance p2 Unlike read() function return the boolean value of checking if the current char at offset from current p2 is equal to “c” or not or if the string ahead is equal to “s” all checks are considered with an offset from p2.

    {{{
    bool readAhead(QChar c);
    bool readAhead(QChar c, int offset);
    bool readAhead(QString s);
    }}}

Responsible to read current char and increment p2 pointer also checks if we are at a newline.

    {{{
    QChar read();
    }}}
    
Returns the string between p1 and p2, inclusive. and then at last sets p1 = p2.

    {{{
    QString accept(int &line, int &col, int &pos);
    }}}

Another version of accept() returns the QString that would've been returned by but doesn't moveahead the pointer p1 to equal p2.

    {{{
    QString acceptable();
    }}}

===Struct StateMachine ===

StateMachine is the physical implementation of regular expressions state machines, where you define a state and the possible transitions from this state to another states(TransitionTable). If for a certain input char at a certain state you defined two unequal transitions for same input the State Machine will always choose the first defined one so it Models the Finite State Machines.

TransitionTable is a Map with States as a Key and a Vector of transition states according to predicates(explained latter) conditions.
    
    {{{
    // given a current state and input, gives us next state
    bool Transition(State s, Buffer &_buffer, State & nextState,bool &accept,
                   TokenType & acceptedType, Action*& action);
    }}}

    {{{
    //Add: takes a current state 's', a predicate 'c', a next state 's2',
    //flags if the state needs them, and a tokenType for the accepted token 
    void add         (State s, Predicate *c, State s2);
    void add         (State s, Predicate *c, State s2, Action *action);
    void addAccepting(State s, Predicate *c, State s2, TokenType accepted);
    void addAccepting(State s, Predicate *c, State s2, TokenType accepted,
                      Action *action);
    }}}

===Class Token===

*We have four types of Tokens:- *
 # *TokenNone* (given int value -1) Tokens of type 'TokenNone' are skipped during lexical analysis.
 # *TokenInvalid* (given int value -2) Invalid tokens are returned by functions that return tokens when they shouldn't, for example Parser.getPos() at the end of file.
 # *TokenWithNext* (-3) & *TokenWithPrev* (-4) that have similar behavior Tokens of type 'WithNext' are skipped when returning the tokenized program, but attached to the 'sister' field in the following token in the token stream the token is lost if there is no following token.

    {{{
    QString Lexeme;
    TokenType Type;
    int Line, Column, Pos;
    void *tag;
    Token *sister;

    //Constructors.
    Token(QString lexeme, TokenType type);
    Token(Token const &other);
    Token();

    //Boolean Operators “==” and “!=” to compare Two Tokens.
    bool operator ==(Token &t2);
    bool operator !=(Token &t2);
    Token &operator = (const Token &other);

    //Overloaded Function “Is” has two signatures either taking lexeme 
    //and compare it or TokenType and checks if they are the same.
    bool Is(QString lexeme);
    bool Is(TokenType type);
    }}}

===Class UnexpectedCharException===

When the state machine is at a non-accepting state and an unexpected char is read Signal an error message with the line, position, character responsible.

    {{{
    QVector<Predicate *> _transitions;
    QString gotThis; //un-expected char that caused the error while parsing
    int line, column, pos;
    int state;
    QString fileName;

    UnexpectedCharException(QString _gotThis, QVector<Predicate *> 
                            possibleTransitions, int line, int column,
                            int pos, int state, QString fileName);
    
    //Err Message = ("Unexpected char:'UnExpectedChar',FileName (Line,Column,
    //               Position) state='State', char code = Char Unicode")       
    QString buildMessage();
    }}}

===Class TransitionTestPair===

Every State holds a vector of TransitionTestPair class where when the Lexical analyzer is at state S will iterate it's vector and try each predicate of the item to check if it holds a valid transition to state S' found in the TransitionTestPair object. 

    {{{
public:
    Predicate *c;
    State s;
    Action *action;
    bool accepting;
    TokenType acceptedType;

public:
    TransitionTestPair();
    TransitionTestPair(Predicate *c1, State s1);
    TransitionTestPair(Predicate *c1, State s1, TokenType _acceptedType);
    TransitionTestPair(Predicate *c1, State s1, Action *_action);
    TransitionTestPair(Predicate *c1, State s1, TokenType _acceptedType,
                       Action *_action); 
    }}}

===Class Lexer===
    
    {{{
    int state;
    QVector<Token> acceptedTokens;
    void *tokenTag;
    QString fileName; // For debugging messages only

public:    
    Lexer();
    Lexer(StateMachine sm);
    void init(QString s);
    void init(QString s, void *tag);
    void init(QString s, void *tag, QString fileName);
    // Runs the state machine and keeps adding accepted tokens to a vector
    void tokenize(bool ignoreUnexpectedChar=false); 
    QVector<Token> getTokens(); // Returns all accepted tokens

protected: 
    StateMachine stateMachine;
    Buffer buffer;
    virtual Token accept(TokenType);
    }}}

===Class KalimatLexer===

    {{{
    //KalimatLexer inherits from Lexer

    CharPredicate *digit, *arabicDigit, *europeanDigit;
    CharPredicate *arabDecimalSeparator, *europeanDecimalSeparator;
    CharPredicate *letter;
    CharPredicate *idSymbol;
    CharPredicate *plus, *minus;
    CharPredicate *mul, *div;
    CharPredicate *lparen, *rparen, *lbracket, *rbracket, *lbrace, *rbrace;
    CharPredicate *dollarSign;
    Predicate *rocket;
    Predicate *matches, *question;
    CharPredicate *spacer, *tab, *space;
    Predicate *lineComment;
    CharPredicate *addOp, *subOp, *mulOp, *divOp, *eq, *lt, *gt;
    Predicate *le,  *ge, *ne;
    Predicate *returnWith;
    CharPredicate *comma, *semi, *colon, *kasra, *hash;
    Predicate *ellipsis;
    CharPredicate *quote;
    Predicate *two_quotes;
    CharPredicate *anyChar, *nl, *noneNl;
    Predicate *sol, *eof;

    Action *retract;
    QMap<QString, int> keywords;
    QMap<QString, QString> arab_chars;
    void InitCharPredicates();
    void InitKeywords();
    void InitArabChars();
    Token accept(TokenType);
public:
    KalimatLexer();
    static QMap<int, QString> tokenNameMap;
    }}}

===Class Predicate===

    {{{
    //Set of Helper Functions Outside Class Predicate
    Predicate *loop(Predicate *p);
    Predicate *choice(Predicate *p1, Predicate *p2);
    Predicate *seq(Predicate *p1, Predicate *p2);
    Predicate *seq(Predicate *p1, Predicate *p2, Predicate *p3);
    Predicate *seq(Predicate *p1, Predicate *p2, Predicate *p3, Predicate *p4);
    Predicate *seq(Predicate *p1, Predicate *p2, Predicate *p3, Predicate *p4,
                   Predicate *p5);
    Predicate *la(CharPredicate *p);
    Predicate *la(QChar p);
    }}}

    {{{
    //virtual Operator that's overloaded in subclasses
    virtual bool operator()(Buffer &b)=0;
    }}}

   # *Class LA :* LookAhead if the passed char pass the Predicate Test.
   # *Class LAStr :* LookAhead a given string and return true if passed buffer holds the given string.
   # *Class Else :* Always returns true.
   # *Class LineStart :* Check if the passed buffer is at the start line.
   # *Class Eof :* Check if the passed buffer is at the EOF state.
   # *Class ReSeq :* Takes Set of Predicates and returns true if all of them pass. 
   # *Class ReChoice :* Takes a set of Predicates and check if any of them pass.
   # *Class ReLoop :* read on the buffer while predicate check pass. 

===Class CharPredicate===

{{{
    //virtual Operator that's overloaded in subclasses
    virtual bool operator()(QChar c)=0;
}}}

*CharPredicate SubClasses :-*

   # *Class CharEquals :* check if passed char equals it's char variable. 
   # *Class CharNotEqual .* 
   # *Class CharIsLetter :* check if passed char isLetter.
   # *Class CharRange :* check if passed char is in a given range.
   # *Class CharOr :*  check if passed char equals one of two chars.
   # *Class AnyChar :* accepts any char.
 