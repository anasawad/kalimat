#summary An explanation of the assembly language for the SmallVM runtime.
The VM takes a string as an input, which represents code in a special assembly language. 

This assembly code has elements of 3 types:
 * Instructions
 * Class definitions
 * Method definitions (the term _method_ here means both normal functions and class member functions).

= Instructions =
An instruction is always on one line. It takes this form:

`label: opcode args @tag`

The _label_ and _tag_ parts are optional, and the arguments vary according to the specific instruction.

For example:
 * `pushv 12`
 * `popl x@14543`
 * `top: add`

== Dealing with variables and values ==

`pushl` _symbol_

Pushes the value of the local variable denoted by _symbol_ on the operand stack.

`popl` _symbol_

Pops a value from the operand stack and assigns this value to the local variable denoted by _symbol_

`pushg` _symbol_

Pushes the value of the *global* variable denoted by _symbol_ on the operand stack.

`popg` _symbol_

Pops a value from the operand stack and assigns this value to the *global* variable denoted by _symbol_

`pushc` _symbol_

Locates the value identified by _symbol_ in the [SmallVmOverview#The_constant_pool constant pool] and pushes that value on the operand stack.

`pushv` _arg_

Pushes the given value _arg_ on the operand stack.

`pushnull`

Pushes the null reference on the operand stack.

== Arithmetic & Logic instructions ==
`add`

Pops two integer, double or string values from the operand stack, add them together, and 
pushes the result. If an integer and a double value are added, the integer will be coerced to double before addition

`sub`

Pops two integer or double values from the operand stack, subtracts the second from the first and pushes the result. If an integer and a double value are subtracted, the integer will be coerced to double before subtraction.

_Stack before:_

`... n1 n2`

_Stack after_

`... (n1 - n2)`

`mul`

Pops two integer or double values from the operand stack, multiplies them together and pushes the result. If an integer and a double value are multiplied, the integer will be coerced to double before multiplication.


`div`

Pops two integer or double values from the operand stack, divides the first by the second and pushes the result. If an integer and a double value are divided, the integer will be coerced to double before division. Signals an error if the divisor is zero.

_Stack before:_

`... n1 n2`

_Stack after_

`... (n1 รท n2)`

`neg`

Pops an integer or double value from the operand stack and pushes back its negative.

`and`

Pops two integers from the operand stack, performs an *and* operation, and pushes the 
result. (Assumes 1 is true and 0 is false).

`or`

Pops two integers from the operand stack, performs an *or* operation, and pushes the result. (Assumes 1 is true and 0 is false).

`not`

Pops an integer from the operand stack and pushes back it's negation. (Assumes 1 is true and 0 is false).

`gt`

`ge`

`lt`

`le`

Pops two integer, double or string values from the operand stack and pushes the result of the comparison (in order: >, >=, <, <=). The result is the boolean 0 or 1. If the two operands are a mix of integer and double the integer is first coerced into double.

`eq`

`ne`

== Control flow ==
`if` _tLabel_, _fLabel_

Pops an integer value from the stack. If the value is zero execution will jump to the label _fLabel_, otherwise it will jump to _tLabel_.

`jmp` _lbl_

Unconditionally transfers execution to the label _lbl_.

`nop`

Does nothing.
== Method calls and event handling ==
`call` _symbol_ _`[`,arity`]`_

Calls a method that's stored in the constant pool under the key _symbol_

Method call works like this:
 # The number of parameters (arity) is determined from the method
 # If the (optional) _arity_ argument is specified in the instruction, the method's actual arity is verified against the given arity.
 # The method arguments are popped from the operand stack, they are assumed to be pushed in reverse order:
  * `... arg_n arg_n-1 .. arg2 arg1`
 # A new frame is created for executing the new method
 # The parameters are copied to the new frame's operand stack. They are laid out so that the method pops its arguments in correct order:
  * `... arg_n arg_n-1 .. arg2 arg1`
 # Execution of the new function begins.

`ret` 

`callex`

`callm`

`regev`

== Arrays ==
`newarr`

`getarr`

`setarr`

`arrlength`

`newmdarr`

`getmdarr`

`setmdarr`

`mdarrdimensions`
== Objects ==
`new`

`getfld`

`setfld`


`callm`
= Method definitions =

A method definition follows the following template:

`.method` _name_ _arity_ _numReturnValues_
     _<instruction 1>_
     _<instruction 2>_
     .....
`.endmethod`

This will define a method object and store it in the constant pool under the key _name_.
The _arity_ and _numReturnValues_ parts are optional. If a single number is provided it is considered the method's arity. The default arity is ... and the default number of return values is ...

= Class definitions =

A class definition follows the following template:

`.class` _name_

    `field` _fieldName1_

    `field` _fieldName2_

    ....

    .method _methodName1_ _arity1_ _numReturnValues1_

        _<instructions...>_

    .endmethod

    ....

`.endclass`